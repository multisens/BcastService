<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Merged VR + Companion + Vote</title>
    <style>
      :root {
        --base-size: 1vw; /* Unidade base baseada na largura da viewport */
      }

      body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        height: 100%;
        font-family: Verdana, sans-serif;
      }

      .main {
        position: relative;
        width: 100vw;
        height: 100vh;
      }
      .main > * {
        position: absolute;
        display: block;
        border: none;
      }

      .popup {
        top: 5vh;
        height: calc(100% - 10vh);
        transform: translateX(-100%);
        width: 15%;
        left: calc(100% - 5vh);
        border-radius: 1vh;
        background-color: rgba(45, 45, 45, 0.9);
        color: rgb(200, 200, 200);
        font-size: calc(1vw + 0.5vh);
        display: grid;
        gap: 1vw;
        grid-template-columns: 100%;
        grid-template-rows: 1fr 5fr 2fr;
        align-items: center;
        z-index: 3;
      }

      .header {
        display: grid;
        align-items: center;
        grid-template-columns: 1fr 1fr;
        grid-template-rows: 100%;
      }
      .header img {
        width: 40%;
        margin-left: auto;
        margin-right: auto;
      }

      .middle {
        display: grid;
        gap: 1vw;
        grid-template-columns: 100%;
        grid-template-rows: 1fr 3fr 2fr;
        align-items: center;
        text-align: center;
      }
      .middle img {
        width: 80%;
        margin-left: auto;
        margin-right: auto;
      }

      .footer {
        display: grid;
        gap: 1vw;
        grid-template-columns: 100%;
        grid-template-rows: 1fr 1fr;
        align-items: center;
      }
      .footer .button {
        background-color: rgb(100, 100, 100);
        background-position: center;
        background-repeat: no-repeat;
        background-size: cover;
        width: 90%;
        height: 6vh;
        margin-left: auto;
        margin-right: auto;
        font-size: calc(1vw + 0.6vh);
        text-align: center;
        display: grid;
        align-items: center;
        border-radius: .6vh;
        cursor: pointer;
      }

      /* Popup de votação */
      .vota {
        position: absolute;
        top: 70%;
        left: 10%;
        width: 80%;
        display: grid;
        gap: 1rem;
        text-align: center;
        font-family: sans-serif;
        font-size: 1.2vw;
        box-sizing: border-box;
        z-index: 2;
      }
      .vota .bg {
        position: absolute;
        inset: 0;
        width: 100%;
        height: 140%;
        object-fit: fill;
        z-index: 0;
      }
      .vota .title {
        position: relative;
        top: 45%;
        z-index: 1;
        color: white;
        font-size: 3vw;
        font-weight: 700;
        text-shadow: 4px 4px 6px #000, -4px -4px 6px #000;
        -webkit-text-stroke: 1px black;
        margin: 0;
      }
      .vota .options {
        position: relative;
        top: 30%;
        left: 3%;
        z-index: 1;
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 1vw;
        justify-items: center;
      }
      .vota .option {
        display: flex;
        align-items: center;
        gap: 0.6vw;
        background: rgba(0, 0, 0, 0);
        border: none;
        border-radius: 0.5vw;
        padding: 0.6vw 1vw;
        cursor: pointer;
        color: white;
        font-weight: bold;
        font-size: 2vw;
        text-align: left;
        text-shadow: 4px 4px 6px #000, -4px -4px 6px #000;
        -webkit-text-stroke: 1px black;
      }
      .vota .option img {
        width: 4vw;
        height: auto;
      }

      .focused {
        outline: 2px solid rgb(200, 200, 200);
      }
    </style>
    <script src="/js/jquery-3.7.1.min.js"></script>
    <script src="/js/navigation.js"></script>
  </head>
  <body>
    <div class="main">
      <!-- Logos -->
      <div id="logos" class="popup" style="background-color: transparent">
        <div class="header">
          <img id="vr" src="media/webmedia/vr-logo.png" moveright="cmp" select="openVRPop"/>
          <img id="cmp" src="media/webmedia/companion-logo.png" moveleft="vr" select="openCMPPop" />
        </div>
      </div>

      <!-- VR Popup -->
      <div id="vrpopup" class="popup">
        <div class="header">
          <img id="vr-logo" src="media/webmedia/vr-logo.png" />
        </div>
        <div class="middle">
          <span>Connect your VR Headset!</span>
          <img src="media/webmedia/video.png" />
        </div>
        <div class="footer">
          <div id="vr-conn" class="button" movedown="vr-back" select="btnVRConn"><span>CONNECTED</span></div>
          <div id="vr-back" class="button" moveup="vr-conn" select="btnVRBack"><span>BACK</span></div>
        </div>
      </div>

      <!-- Companion Popup -->
      <div id="cmppopup" class="popup">
        <div class="header">
          <span></span>
          <img id="cmp-logo" src="media/webmedia/companion-logo.png" />
        </div>
        <div class="middle">
          <span>Open your <br /> Companion App</span>
          <img src="media/webmedia/qrcode.png" />
        </div>
        <div class="footer">
          <div id="cmp-conn" class="button" movedown="cmp-back" select="btnCMPConn"><span>CONNECTED</span></div>
          <div id="cmp-back" class="button" moveup="cmp-conn" select="btnCMPBack"><span>BACK</span></div>
        </div>
      </div>

      <!-- Vote Popup -->
      <div id="votapopup" class="vota">
        <img class="bg" src="media/webmedia/popup-background.png" alt="fundo" />
        <h2  id="txt_vitoria" class="title">Escolha do Replay</h2>
        <div id="votacao" class="options">
          <button class="option" type="button">
            <img id="vot_1" src="media/webmedia/icon_arrow1.png" alt="" />
            <span>Comissão de Frente</span>
          </button>
          <button class="option" type="button">
            <img id="vot_2" src="media/webmedia/icon_arrow2.png" alt="" />
            <span>Abre-alas</span>
          </button>
          <button class="option" type="button">
            <img id="vot_3" src="media/webmedia/icon_arrow3.png" alt="" />
            <span>Mestre Sala e <br>Porta Bandeira</span>
          </button>
        </div>

        <div>
            <span></span>
        </div>

      </div>
    </div>

    <script>
      // --------------------------
      // Navegação e mensagens
      // --------------------------
      let video_timer = 0;
      let timer_vote = 0;

      window.addEventListener('message', receiveFrameMessage);
      document.addEventListener('keydown', (e) => {
        navigate(e.key);
      });

      document.addEventListener('timeupdate', (e) => {
        console.log('Tempo transmissão:' + e.detail);
        if (e.detail >= 10 && video_timer == 0) {
                declareVencedor();
                video_timer += 1;
                timer_vote = 0;
              }
      });

      function receiveFrameMessage(e) {
        try {
          // Algumas integrações enviam string JSON
          const m = JSON.parse(e.data);
          if (m && m.type === 'keydown' && m.key) {
            document.dispatchEvent(new KeyboardEvent('keydown', { key: m.key }));
          }
        } catch (_) {
          // Silencia erros de parse
        }
      }
        setInterval(() => {
          if(video_timer == 1)
          {
            if(timer_vote >= 60)
            {
                stopVote();
                video_timer += 1;
            }
            else
            { timer_vote +=1; }
          }
        }, 1000);

      // Estado inicial da UI
      $('#logos').show();
      $('#vrpopup').hide();
      $('#cmppopup').hide();
      $('#votapopup').hide();
      $('#votacao').hide();
      $('#vr').addClass('focused');

      function startVote() {
        $('#votapopup').show();
        $('#votacao').show();
      }
      function stopVote() {
        $('#votapopup').hide();
      }

      function openVRPop() {
        $('#logos').hide();
        $('#vrpopup').show();
        $('#cmppopup').hide();
        $('#vr').removeClass('focused');
        $('#vr-conn').addClass('focused');

        getNCL360device()
      }

      function openCMPPop() {
        $('#logos').hide();
        $('#vrpopup').hide();
        $('#cmppopup').show();
        $('#cmp').removeClass('focused');
        $('#cmp-conn').addClass('focused');
      }

      function btnBack() {
        $('#logos').show();
        $('#vrpopup').hide();
        $('#cmppopup').hide();
      }
      function btnVRBack() {
        btnBack();
        $('#vr-back').removeClass('focused');
        $('#vr').addClass('focused');
      }
      function btnCMPBack() {
        btnBack();
        $('#cmp-back').removeClass('focused');
        $('#cmp').addClass('focused');
      }

      // --------------------------
      // WebSockets e dispositivos
      // --------------------------
      let MSG_COUNT = 0;
      let handle_vr = '';
      let handle_companion = [];
  let companionDevices = []; // lista com os dispositivos companion obtidos do CCWS
  let companionSockets = []; // array de { url, socket }
  // buffer simples para armazenar mensagens recebidas dos sockets diretos
  let companionMessages = []; // { url, raw, parsed?, timestamp }
      let ws_VR;

      async function getNCL360device() {
        const url = 'http://localhost:44642/tv3/remote-device/devices/guarana';
        try {
          const resp = await fetch(url, { method: 'GET' });
          if (!resp.ok) {
            console.error('Failed to fetch companion devices', resp.status, resp.statusText);
            return [];
          }
          const data = await resp.json();
          console.log("Ultimo device NCL360 ", data.devices[data.devices.length - 1].handle );

          handle_device_NCL360 = data.devices[data.devices.length - 1].handle;
          handle_vr = handle_device_NCL360;
          const resp_1 = await fetch(`http://localhost:44642/tv3/remote-device/device/${handle_device_NCL360}`);
          if (!resp_1.ok) return { handle: h, urls: [] };
          const info = await resp_1.json();

          console.log("Url device NCL360 ", info );

          ws_VR = new WebSocket('ws://localhost:' + info.url.slice(-4));
          
          ws_VR.onopen = function () {
            console.log('Connection opened...');
          };
          ws_VR.onmessage = ReceiveDeviceMessage;
          ws_VR.onclose = function () {
            console.log('Connection closed...');
            MSG_COUNT = 0;
          };
        } catch (err) {
          console.error('Error fetching NCL360 devices', err);
          return [];
        }
      }
      
      
      function ReceiveDeviceMessage(evt) {
        try {
          const msg = JSON.parse(evt.data);
          console.log(JSON.stringify(msg, undefined, 2));

          if (msg && msg.message && msg.message.deviceClass === 'guarana') {
            handle_vr = msg.handle;
            con
          } else if (msg && msg.message && msg.message.deviceClass === 'companion') {
            // aceita tanto string quanto objeto
            if (!handle_companion.includes(msg.handle)) handle_companion.push(msg.handle);
          }
          MSG_COUNT += 1;
        } catch (err) {
          console.error('ReceiveDeviceMessage parse error', err);
        }
      }

      // Busca os dispositivos companion registrados no CCWS e armazena o resultado
      async function getcompaniondevices() {
        const url = 'http://localhost:44642/tv3/remote-device/devices/companion';
        try {
          const resp = await fetch(url, { method: 'GET' });
          if (!resp.ok) {
            console.error('Failed to fetch companion devices', resp.status, resp.statusText);
            return [];
          }
          const data = await resp.json();
          companionDevices = Array.isArray(data) ? data : [data];
          console.log('Companion devices fetched:', companionDevices);

          // Atualiza os handles, se existirem
          const handles = companionDevices
            .flatMap((d) => (d && d.devices ? d.devices : [d]))
            .map((d) => d && d.handle)
            .filter(Boolean);
          if (handles.length) {
            handle_companion = Array.from(new Set(handles));
            console.log('Updated handle_companion:', handle_companion);
          }
          return companionDevices;
        } catch (err) {
          console.error('Error fetching companion devices', err);
          return [];
        }
      }

      // Retorna lista de URLs por handle (deduplicadas)
      async function getSocketUrlByHandle() {
        const devices = await getcompaniondevices();
        const handles = (devices || [])
          .flatMap((item) => (item && item.devices ? item.devices : [item]))
          .map((d) => d && d.handle)
          .filter(Boolean);
        if (!handles || handles.length === 0) return [];

        const results = await Promise.all(
          handles.map(async (h) => {
            try {
              const resp = await fetch(`http://localhost:44642/tv3/remote-device/device/${h}`);
              if (!resp.ok) return { handle: h, urls: [] };
              const info = await resp.json();
              const urls = [];

              if (typeof info === 'string') urls.push(info);
              if (Array.isArray(info?.urls)) urls.push(...info.urls);
              if (typeof info?.url === 'string') urls.push(info.url);
              if (Array.isArray(info?.devices)) info.devices.forEach((d) => d?.url && urls.push(d.url));

              // scan genérico
              Object.values(info || {}).forEach((v) => {
                const isUrl = (s) => typeof s === 'string' && /^(https?:\/\/|wss?:\/\/)/.test(s);
                if (isUrl(v)) urls.push(v);
                if (Array.isArray(v)) v.forEach((x) => isUrl(x) && urls.push(x));
              });

              return { handle: h, urls: Array.from(new Set(urls)) };
            } catch (err) {
              return { handle: h, urls: [], error: String(err) };
            }
          })
        );

        const uniqueUrls = Array.from(new Set(results.flatMap((r) => (r && r.urls ? r.urls : [])).filter(Boolean)));
        return uniqueUrls;
      }

      // Abre sockets diretos com cada companion
      async function openSocketByDevice() {
        try {
          const urls = await getSocketUrlByHandle();
          // fecha anteriores
          companionSockets.forEach((e) => {
            try {
              e.socket.close();
            } catch (_) {}
          });
          companionSockets = [];

          urls.forEach((url) => {
            try {
              const s = new WebSocket(url);

              s.addEventListener('open', () => console.log('Socket open', url));

              // coleta mensagens recebidas no buffer global companionMessages
              s.addEventListener('message', (ev) => {
                const raw = ev.data;
                let parsed = null;
                try {
                  if (typeof raw === 'string') parsed = JSON.parse(raw);
                } catch (_) {
                  // mensagem não é JSON — mantemos raw
                }
                companionMessages.push({ url, raw, parsed, timestamp: Date.now() });
                console.log('Socket message', url, raw);
              });

              s.addEventListener('close', () => console.log('Socket closed', url));
              s.addEventListener('error', (err) => console.error('Socket error', url, err));

              companionSockets.push({ url, socket: s });
            } catch (err) {
              console.error('Failed to open socket for', url, err);
            }
          });
          return companionSockets;
        } catch (err) {
          console.error('openSocketByDevice failed', err);
          return [];
        }
      }

      // Utilitários de envio
      function SendConfigManual(wsTarget, config) {
        try {
          wsTarget.send(JSON.stringify(config));
        } catch (err) {
          console.error('SendConfigManual error', err);
        }
      }

      function SendDeviceMessage(wsTarget, handle, form) {
        if (!handle) {
          alert('Dispositivo não encontrado');
          return;
        }
        try {
          wsTarget.send(
            JSON.stringify({
              service: 'remotedevice',
              handle: handle,
              message: form,
            })
          );
          console.log('Device Message Sent to', handle);
        } catch (err) {
          console.error('Device send failed', handle, err);
        }
      }

      function BroadcastToCompanionViaCCWS(form) {
        if (!handle_companion || handle_companion.length === 0) {
          alert('Nenhum dispositivo companion encontrado');
          return;
        }
        handle_companion.forEach((h) => SendDeviceMessage(ws, h, form));
      }

      function BroadcastToCompanionDirectSockets(payload) {
        // Se houver sockets diretos abertos, envia também por eles
        const data = typeof payload === 'string' ? payload : JSON.stringify(payload);
        companionSockets.forEach((entry) => {
          try {
            entry.socket.send(data);
          } catch (err) {
            console.error('Direct socket send failed', entry.url, err);
          }
        });
      }

      // Envia a mensagem de abertura de URL para UM handle específico, usando apenas
      async function SendOpenUrlCommand(handle, url) {
        if (!handle || !url) {
          console.error('SendOpenUrlCommand: handle e url são obrigatórios');
          return { ok: false, error: 'missing_handle_or_url' };
        }

        // tenta casar diretamente com companionSockets usando comparações flexíveis
        function urlsMatch(a, b) {
          if (!a || !b) return false;
          if (a === b) return true;
          try {
            const pa = new URL(a).href;
            const pb = new URL(b).href;
            if (pa === pb) return true;
            if (pa.endsWith(pb) || pb.endsWith(pa)) return true;
            if (pa.includes(pb) || pb.includes(pa)) return true;
          } catch (_) {
            if (a.endsWith(b) || b.endsWith(a) || a.includes(b) || b.includes(a)) return true;
          }
          return false;
        }

        let foundEntry = null;
        // 1) tentar encontrar por igualdade/substring com a url passada
        for (const entry of companionSockets) {
          if (!entry || !entry.url) continue;
          if (urlsMatch(entry.url, url)) { foundEntry = entry; break; }
        }

        // 2) se não encontrou, buscar URLs do device no CCWS e tentar casar
        if (!foundEntry) {
          try {
            const resp = await fetch(`http://localhost:44642/tv3/remote-device/device/${handle}`);
            if (resp.ok) {
              const info = await resp.json();
              const candidateUrls = [];
              if (typeof info === 'string') candidateUrls.push(info);
              if (Array.isArray(info?.urls)) candidateUrls.push(...info.urls);
              if (typeof info?.url === 'string') candidateUrls.push(info.url);
              if (Array.isArray(info?.devices)) info.devices.forEach((d) => d?.url && candidateUrls.push(d.url));
              Object.values(info || {}).forEach((v) => {
                if (typeof v === 'string') candidateUrls.push(v);
                if (Array.isArray(v)) v.forEach((x) => typeof x === 'string' && candidateUrls.push(x));
              });

              for (const cu of candidateUrls) {
                for (const entry of companionSockets) {
                  if (!entry || !entry.url) continue;
                  if (urlsMatch(entry.url, cu)) { foundEntry = entry; break; }
                }
                if (foundEntry) break;
              }
            }
          } catch (err) {
            console.warn('SendOpenUrlCommand: erro ao buscar device info', handle, err);
          }
        }

        if (!foundEntry || !foundEntry.socket) {
          console.error('SendOpenUrlCommand: nenhum socket direto encontrado para handle', handle);
          return { ok: false, error: 'no_direct_socket_for_handle' };
        }

        const sock = foundEntry.socket;
        if (sock.readyState !== WebSocket.OPEN) {
          console.error('SendOpenUrlCommand: socket não está aberto', foundEntry.url, sock.readyState);
          return { ok: false, error: 'socket_not_open', state: sock.readyState };
        }

        const message = {
          service: 'remotedevice',
          handle: handle,
          message: {
            deviceClass: 'companion',
            url: url,
          },
        };

        try {
          sock.send(JSON.stringify(message));
          console.log('SendOpenUrlCommand: enviado para handle', handle, 'via', foundEntry.url);
          return { ok: true };
        } catch (err) {
          console.error('SendOpenUrlCommand: falha ao enviar', err);
          return { ok: false, error: String(err) };
        }
      }
      
      // Helpers para acessar/limpar as mensagens coletadas dos sockets diretos
      function getCollectedCompanionMessages() {
        return companionMessages.slice(); // devolve cópia
      }

      function clearCollectedCompanionMessages() {
        companionMessages.length = 0;
      }
      
      // --------------------------
      // Ações de botões
      // --------------------------
      async function btnVRConn() {
        // Configurações iniciais
        SendConfigManual(ws_VR, {
          service: 'appfiles',
          appid: '100',
          path: 'D:/GitHub/Guarana-Testing/WebMedia',
        });
        SendConfigManual(ws_VR, {
          service: 'userapi',
          path: 'D:/GitHub/Guarana-Testing/UserAPI',
          currentUser: 'f626b4f2-d989-4fbf-9645-f830fd12b348',
          currentService: 'midiacom',
        });

        // Carrega cena
        SendDeviceMessage(ws_VR, handle_vr, {
          nodeId: 'm1',
          nodeSrc: 'cena.ncl360',
          appId: '100',
          type: 'application/x-ncl360',
        });
        
        // Dispara presentation.start
        SendDeviceMessage(ws_VR, handle_vr, {
          nodeId: 'm1',
          label: '',
          appId: '100',
          eventType: 'presentation',
          action: 'start',
        });
      }

      async function btnCMPConn() {
        // Abre sockets diretos para companions descobertos
        await openSocketByDevice();

        // Exemplo: envia um ping de teste para companions via CCWS e sockets diretos
        const msg = { type: 'hello', at: Date.now() };
        BroadcastToCompanionViaCCWS(msg);
        BroadcastToCompanionDirectSockets(msg);
      }

      function btnVote(option) {
        // Envia voto selecionado aos companions
        const payload = { type: 'vote', option };
        BroadcastToCompanionViaCCWS(payload);
        BroadcastToCompanionDirectSockets(payload);

        // Feedback local simples
        console.log('Voto enviado:', option);
        // Opcional: esconder popup após voto
        // $('#votapopup').hide();
      }

      function declareVencedor() {
        $('#votapopup').show();
        $('#votacao').hide();

        const mySpan = document.getElementById("txt_vitoria");
        const escola1 = "Grande Rio";
        const escola2 = "Imperatriz Leopoldinense";
        mySpan.innerText = '1º colocado: '+escola1+' ! 2º colocado: '+escola2+' !'; 
      }

      // Expondo funções globais para o navigation.js acionar via atributo `select`.
      window.openVRPop = openVRPop;
      window.openCMPPop = openCMPPop;
      window.btnVRConn = btnVRConn;
      window.btnVRBack = btnVRBack;
      window.btnCMPConn = btnCMPConn;
      window.btnCMPBack = btnCMPBack;
      window.btnVote = btnVote;
  // expose message buffer helpers
  window.getCollectedCompanionMessages = getCollectedCompanionMessages;
  window.clearCollectedCompanionMessages = clearCollectedCompanionMessages;
    </script>
  </body>
</html>
